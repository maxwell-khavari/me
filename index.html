<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Maxwell Khavari â€“ AI & Fairness Projects</title>
    <small>Gunn High School 2029</small>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-card: #1a1a1a;
            --bg-gradient: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            --accent-primary: #00d4ff;
            --accent-secondary: #7c3aed;
            --accent-tertiary: #06ffa5;
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --border: #27272a;
            --shadow-glow: 0 0 20px rgba(0, 212, 255, 0.1);
            --shadow-intense: 0 8px 32px rgba(0, 0, 0, 0.3);
            --gradient-text: linear-gradient(135deg, #00d4ff 0%, #7c3aed 50%, #06ffa5 100%);
            --gradient-border: linear-gradient(135deg, #00d4ff 0%, #7c3aed 50%, #06ffa5 100%);

            /* New and refined variables for drastic improvement */
            --font-heading: 'Inter', sans-serif;
            --font-body: 'Inter', sans-serif;
            --spacing-unit: 1rem;
            --border-radius-large: 20px;
            --border-radius-medium: 12px;
            --transition-speed: 0.8s; /* Slower for more fluidity */
            --transition-ease: cubic-bezier(0.25, 0.8, 0.25, 1); /* Smoother easing */
            --shadow-subtle: 0 4px 15px rgba(0, 0, 0, 0.2);
            --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.4);
            --glow-primary: 0 0 15px rgba(0, 212, 255, 0.4);
            --glow-secondary: 0 0 15px rgba(124, 58, 237, 0.4);

            /* New text specific variables */
            --text-shadow-fluid: 0 0 10px rgba(255, 255, 255, 0.05); /* Very subtle white glow */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            overflow-x: hidden;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-smoothing: grayscale;
        }

        /* Animated background particles */
        .bg-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: var(--accent-primary);
            border-radius: 50%;
            animation: float 12s infinite ease-in-out;
            opacity: 0.4;
            filter: blur(0.5px);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) translateX(0) rotate(0deg); opacity: 0.4; }
            25% { transform: translateY(-30px) translateX(20px) rotate(90deg); opacity: 0.6; }
            50% { transform: translateY(-60px) translateX(-40px) rotate(180deg); opacity: 0.8; }
            75% { transform: translateY(-30px) translateX(20px) rotate(270deg); opacity: 0.6; }
        }

        /* Floating GitHub button with enhanced styling */
        .floating-github {
            position: fixed;
            top: var(--spacing-unit);
            right: var(--spacing-unit);
            background: rgba(26, 26, 26, 0.7); /* Slightly more transparent */
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.7rem 1.4rem;
            border-radius: 50px;
            font-weight: 600;
            box-shadow: var(--shadow-glow);
            cursor: pointer;
            z-index: 200;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.6rem;
            transition: all var(--transition-speed) var(--transition-ease);
            backdrop-filter: blur(15px); /* Increased blur */
            font-size: 0.9rem;
            letter-spacing: 0.02em;
        }

        .floating-github:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            transform: translateY(-3px) scale(1.02); /* Added slight scale */
            box-shadow: 0 0 35px rgba(0, 212, 255, 0.4); /* Stronger glow */
        }

        .floating-github svg {
            width: 17px;
            height: 17px;
            fill: currentColor;
            transition: transform var(--transition-speed) ease;
        }

        .floating-github:hover svg {
            transform: rotate(360deg) scale(1.1);
        }

        header {
            background: var(--bg-secondary);
            text-align: center;
            padding: 5rem 1.5rem 4rem; /* More vertical padding */
            position: relative;
            overflow: hidden;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px; /* Ensure a good height */
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gradient-border);
            opacity: 0.15; /* Slightly more visible gradient */
            z-index: 1;
        }

        header > * {
            position: relative;
            z-index: 2;
        }

        header h1 {
            font-family: var(--font-heading);
            font-size: 4.2rem; /* Larger font size */
            font-weight: 800; /* Bolder for impact */
            margin: 0.5rem 0 0.8rem;
            background: var(--gradient-text);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            /* opacity and animation handled by JS */
            letter-spacing: -0.05em; /* Tighter letter spacing */
            text-shadow: var(--glow-primary); /* Use primary glow for main heading */
        }

        header p {
            font-size: 1.3rem; /* Larger font size */
            color: var(--text-secondary);
            margin: 0 0 1.5rem;
            /* opacity and animation handled by JS */
            font-weight: 500;
            max-width: 700px;
            line-height: 1.5;
            text-shadow: var(--text-shadow-fluid); /* Apply subtle fluid shadow */
        }

        .container {
            max-width: 1000px;
            margin: auto;
            padding: 4rem 1.5rem; /* More padding */
            position: relative;
            z-index: 10;
        }

        section {
            background: var(--bg-card);
            margin-bottom: 3rem; /* More space between sections */
            padding: 3rem; /* More internal padding */
            border-radius: var(--border-radius-large); /* Larger border radius */
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            opacity: 0;
            animation: slideInUp 1.2s var(--transition-ease) forwards;
            backdrop-filter: blur(15px); /* Increased blur */
            box-shadow: var(--shadow-subtle);
        }

        section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px; /* Thicker border */
            background: var(--gradient-border);
            transform: translateX(-100%);
            animation: slideInBorder 1.2s var(--transition-ease) 0.8s forwards;
        }

        section:nth-child(1) { animation-delay: 0.2s; }
        section:nth-child(2) { animation-delay: 0.4s; }
        section:nth-child(3) { animation-delay: 0.6s; }
        section:nth-child(4) { animation-delay: 0.8s; }
        section:nth-child(5) { animation-delay: 1s; }

        section:hover {
            transform: translateY(-5px); /* More pronounced lift */
            box-shadow: var(--shadow-hover); /* Stronger shadow on hover */
            transition: all var(--transition-speed) var(--transition-ease);
            border-color: var(--accent-primary); /* Highlight border on hover */
        }

        h2 {
            font-family: var(--font-heading);
            color: var(--text-primary);
            font-size: 2.8rem; /* Larger font size */
            font-weight: 700;
            margin-top: 0;
            margin-bottom: 2rem; /* More space below heading */
            position: relative;
            /* opacity and animation handled by JS */
            letter-spacing: -0.03em;
            text-shadow: var(--text-shadow-fluid);
        }

        h2::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -12px; /* Lower the line */
            height: 3px; /* Thicker line */
            width: 80px; /* Longer line */
            background: var(--gradient-border);
            animation: expandLine 1.2s var(--transition-ease) 1.1s forwards;
            transform: scaleX(0);
            transform-origin: left;
        }

        h3 {
            font-family: var(--font-heading);
            color: var(--accent-primary);
            font-size: 1.6rem; /* Larger font size */
            font-weight: 600;
            margin-top: 2.5rem; /* More space above */
            margin-bottom: 1.2rem;
            /* opacity and animation handled by JS */
            letter-spacing: 0.01em;
            text-shadow: var(--text-shadow-fluid);
        }

        ul {
            padding-left: 1.8rem; /* More padding */
            margin-top: 0;
            list-style: none; /* Remove default bullet */
        }

        ul li {
            margin-bottom: 1.2rem; /* More space between list items */
            color: var(--text-secondary);
            position: relative;
            padding-left: 1.5rem; /* Space for custom bullet */
            font-size: 1.05rem;
            /* opacity and animation handled by JS */
            text-shadow: var(--text-shadow-fluid);
        }

        ul li::before {
            content: 'â€¢'; /* Custom bullet point */
            position: absolute;
            left: 0;
            color: var(--accent-tertiary); /* Different accent color for bullet */
            font-size: 1.2rem;
            top: -2px;
        }

        p {
            margin-top: 0;
            color: var(--text-secondary);
            /* opacity and animation handled by JS */
            font-weight: 400;
            font-size: 1.05rem;
            line-height: 1.8;
            text-shadow: var(--text-shadow-fluid);
        }

        a {
            color: var(--accent-primary);
            text-decoration: none;
            font-weight: 500;
            transition: all var(--transition-speed) ease;
            position: relative;
        }

        a::after {
            content: '';
            position: absolute;
            bottom: -3px; /* Lower the underline */
            left: 0;
            width: 0;
            height: 2px; /* Thicker underline */
            background: var(--accent-primary);
            transition: width var(--transition-speed) ease;
        }

        a:hover::after {
            width: 100%;
            background: var(--accent-tertiary); /* Change color on hover */
        }

        a:hover {
            color: var(--accent-tertiary);
            text-shadow: 0 0 15px rgba(6, 255, 165, 0.4); /* More intense shadow */
        }

        .projects a, .cta-button {
            display: block;
            margin: 2rem 0; /* More margin */
            padding: 1.2rem 2.5rem; /* More padding */
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-weight: 600;
            text-align: center;
            border-radius: var(--border-radius-medium);
            transition: all var(--transition-speed) var(--transition-ease);
            position: relative;
            overflow: hidden;
            font-size: 1.1rem;
            letter-spacing: 0.03em;
            box-shadow: var(--shadow-subtle); /* Add subtle shadow to buttons */
        }

        .projects a::before, .cta-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--gradient-border);
            transition: left 0.6s var(--transition-ease);
            z-index: 1;
        }

        .projects a > *, .cta-button > * {
            position: relative;
            z-index: 2;
        }

        .projects a:hover::before, .cta-button:hover::before {
            left: 0;
        }

        .projects a:hover, .cta-button:hover {
            transform: translateY(-5px); /* More pronounced lift */
            box-shadow: 0 15px 40px rgba(0, 212, 255, 0.3); /* Stronger shadow */
            color: var(--bg-primary);
        }

        .highlight {
            font-weight: 700;
            background: var(--gradient-text);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: var(--glow-primary); /* Apply glow to highlights */
        }

        .status-update {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border: 1px solid var(--accent-secondary);
            border-left: 6px solid var(--accent-secondary); /* Thicker left border */
            padding: 2rem; /* More padding */
            margin-bottom: 2.5rem;
            border-radius: var(--border-radius-medium);
            color: var(--text-primary);
            font-weight: 500;
            position: relative;
            overflow: hidden;
            opacity: 0;
            animation: slideInRight 1.2s var(--transition-ease) 0.9s forwards;
            box-shadow: var(--shadow-subtle);
            font-size: 1.05rem;
            line-height: 1.6;
            text-shadow: var(--text-shadow-fluid);
        }

        .status-update::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(124, 58, 237, 0.15) 0%, transparent 70%); /* Stronger glow */
            animation: pulse 4s ease-in-out infinite; /* Slower pulse */
        }

        footer {
            text-align: center;
            background: var(--bg-secondary);
            color: var(--text-muted);
            padding: 3rem 1.5rem; /* More padding */
            font-size: 0.95rem;
            border-top: 1px solid var(--border);
            position: relative;
            line-height: 1.8;
            text-shadow: var(--text-shadow-fluid);
        }

        footer a {
            color: var(--accent-primary);
            font-weight: 600;
        }

        /* ----- New CSS for Bouncing Words ----- */
        .word-container {
            position: relative; /* All parent elements for words need relative positioning */
            display: block; /* Typically paragraphs and headings are block */
            line-height: inherit; /* Inherit line-height for proper spacing */
            font-size: inherit; /* Inherit font-size */
            font-weight: inherit; /* Inherit font-weight */
            padding: 0;
            margin: 0;
            /* Hide the original text, as word particles will be placed */
            color: transparent !important; /* Force transparent */
            /* Crucial: Hide overflow for the bouncing phase */
            overflow: hidden;
            /* Ensure the container has a defined height during calculation */
            min-height: 1em; /* or auto for block elements */
        }
        
        /* Specific styles for word containers that are headings */
        h1.word-container {
            background: var(--gradient-text);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: var(--glow-primary);
        }

        .word-particle {
            position: absolute;
            opacity: 0;
            transform: translate(0, 0); /* Initial state, will be overwritten by JS */
            filter: blur(5px); /* Initial blur */
            /* Add long transition for settling phase */
            transition: opacity 2s var(--transition-ease),
                        transform 2s var(--transition-ease),
                        filter 2s var(--transition-ease);
            white-space: nowrap; /* Prevent words from breaking */
            display: inline-block; /* Ensures consistent box model */
            pointer-events: none; /* Do not block clicks on elements behind */
            z-index: 100; /* Ensure words are on top during animation */
            /* Inherit font styles */
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            line-height: inherit;
            color: inherit; /* Inherit color from the parent container initially */
            text-shadow: inherit; /* Inherit text shadow */
        }

        /* Style for highlight words within the word-particle spans */
        .word-particle.highlight-word {
            background: var(--gradient-text);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: var(--glow-primary);
        }


        /* --- Existing Animations (adjusted or retained) --- */
        @keyframes fadeInScale {
            0% {
                opacity: 0;
                transform: scale(0.7) translateY(40px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes fadeInUp {
            0% {
                opacity: 0;
                transform: translateY(40px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInUp {
            0% {
                opacity: 0;
                transform: translateY(60px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInRight {
            0% {
                opacity: 0;
                transform: translateX(60px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInBorder {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(0);
            }
        }

        @keyframes expandLine {
            0% {
                transform: scaleX(0);
            }
            100% {
                transform: scaleX(1);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.4;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.03);
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 3rem;
            }
            header p {
                font-size: 1.1rem;
            }
            h2 {
                font-size: 2.2rem;
            }
            h3 {
                font-size: 1.4rem;
            }
            section {
                padding: 2rem 1.5rem;
            }
            .floating-github {
                padding: 0.6rem 1.2rem;
                font-size: 0.85rem;
                top: 10px;
                right: 10px;
            }
            .container {
                padding: 2rem 1rem;
            }
            ul li, p, .status-update {
                font-size: 1rem;
            }
            .projects a, .cta-button {
                font-size: 1rem;
                padding: 1rem 2rem;
            }
        }

        /* Scroll animations (kept for consistency) */
        @media (prefers-reduced-motion: no-preference) {
            /* These will be partially overridden by JS-driven animations */
            section {
                animation: slideInUp 1s ease forwards;
            }
        }
    </style>
</head>
<body>

<div class="bg-particles" id="particles"></div>

    <a href="https://github.com/maxwell-khavari" target="_blank" rel="noopener noreferrer" class="floating-github" aria-label="Visit Maxwell Khavari GitHub">
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.485 2 12.019c0 4.426 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.009-.868-.014-1.703-2.782.604-3.369-1.343-3.369-1.343-.454-1.156-1.11-1.464-1.11-1.464-.908-.62.069-.608.069-.608 1.003.07 1.531 1.031 1.531 1.031.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.114-4.555-4.958 0-1.095.39-1.991 1.029-2.694-.103-.254-.446-1.273.098-2.654 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.845c.85.004 1.705.115 2.504.337 1.908-1.296 2.746-1.026 2.746-1.026.546 1.381.202 2.4.1 2.654.64.703 1.028 1.599 1.028 2.694 0 3.854-2.338 4.7-4.566 4.95.359.309.678.918.678 1.852 0 1.336-.012 2.416-.012 2.744 0 .268.18.58.688.481A10.019 10.019 0 0022 12.019C22 6.485 17.523 2 12 2z"/></svg>
        GitHub
    </a>

    <header>
        <h1 id="header-h1">Maxwell Khavari</h1>
        <p id="header-p">AI Researcher â€¢ Developer â€¢ Gunn High School Student</p>
    </header>

    <div class="container">
        <section>
            <h2 id="section1-h2">About My Work</h2>
            <p id="section1-p1">
                My core focus is on understanding and actively addressing algorithmic bias in AI systems â€” particularly within
                text-to-image generation and classification models. It's crucial work because these powerful systems, if left
                unchecked, can inadvertently reinforce harmful stereotypes. My goal is to ensure they become fairer and
                more representative of our diverse world.
            </p>
            <p id="section1-p2">
                My current research delves into how race, gender, and socioeconomic status are represented in AI-generated
                imagery and within classification tasks. I'm developing methods to reverse-engineer prompts and model decisions,
                allowing us to thoroughly audit and improve AI fairness.
            </p>
            <p id="section1-p3">
                Additionally, I build convolutional neural networks (CNNs), especially for image analysis tasks. I've developed and run small-scale CNN models in Google Colab to experiment with various architectures and datasets.
            </p>
        </section>

        <section>
            <h2 id="section2-h2">Current Project: Algorithmic Bias Progression Over Time</h2>
            <h3 id="section2-h3-1">The Problem &amp; Opportunity</h3>
            <ul id="section2-ul1">
                <li id="section2-ul1-li1"><strong>Persistent Algorithmic Bias:</strong> Text-to-image AIs generate biased visuals (e.g., for professions, leadership)
                    even from neutral prompts (e.g., "CEO," "nurse," "leader").
                    These biases stem from vast, real-world datasets that unfortunately carry existing societal biases related to race, gender, status, and intelligence.
                </li>
                <li id="section2-ul1-li2"><strong>Temporal Blind Spot:</strong> There's a significant gap in understanding how these biases <span class="highlight">persist and significantly change over time</span> across different model versions.</li>
                <li id="section2-ul1-li3"><strong>Bias Injection at the Source:</strong> A critical observation is that language models can introduce bias during prompt reconstruction, <em>before</em> the image is generated.</li>
                <li id="section2-ul1-li4"><strong>Overlooked Human Perception:</strong> Critically, the concept of "bias" isn't uniformly perceived. What an algorithm deems neutral, or what one group finds subtly biased, another might experience as overtly offensive. Relying solely on technical metrics misses this vital human dimension of fairness.</li>
            </ul>
            <h3 id="section2-h3-2">Our Core Hypothesis</h3>
            <p id="section2-p4">
                Text-to-image models exhibit biases related to socioeconomic status, intelligence, occupational prestige, or leadership, which <span class="highlight">persist and significantly change over time</span>, even when prompts do not explicitly mention gender or race. Furthermore, the human perception and interpretation of these algorithmic biases vary significantly across evaluators from diverse racial and gender backgrounds, revealing distinct subjective experiences of algorithmic fairness.
            </p>
            <h3 id="section2-h3-3">Project Goals</h3>
            <ul id="section2-ul2">
                <li id="section2-ul2-li1">Quantify the percentage change in gender and racial representation for specific prompts across different model versions over time.</li>
                <li id="section2-ul2-li2">Identify and document distinct patterns of algorithmic bias progression (e.g., increasing, decreasing, stable).</li>
                <li id="section2-ul2-li3"><strong>Quantify the variance in bias perception among human evaluators, demonstrating statistically significant differences based on their racial and gender backgrounds.</strong></li>
                <li id="section2-ul2-li4">Generate a robust dataset of over 5,000 images, complete with algorithmic bias metrics and human perception ratings, and make it publicly available.</li>
            </ul>
            <div class="status-update">
                <p id="status-p">
                    <strong>Current Status Update:</strong> I'm happy to report that I have most of the automation code and analysis code for the dataset complete. All I need to do is adjust the locators for different models and tweak small parts of it. This means we're in a strong position to generate the data and start the analysis very soon! The groundwork for the human perception study will build directly on these generated images.
                </p>
            </div>
            <a href="INSERT_LINK_HERE" class="cta-button" target="_blank" rel="noopener noreferrer">View Full Project PRD (PDF/Document)</a>
        </section>

        <section>
            <h2 id="section3-h2">Project Components &amp; Methodology Highlights</h2>
            <h3 id="section3-h3-1">Core Domains for Bias Analysis ("Rule of 3")</h3>
            <ul id="section3-ul1">
                <li id="section3-ul1-li1"><strong>Medical &amp; Healthcare Professions:</strong> Examining roles like "nurse," "surgeon," "paramedic" for intersectional bias (prestige, gender coding, racial representation).</li>
                <li id="section3-ul1-li2"><strong>Patients &amp; Students:</strong> Analyzing depictions of roles often visualized with infantilizing, racialized, or stereotypically passive attributes.</li>
                <li id="section3-ul1-li3"><strong>Power, Visibility, &amp; Cultural Authority:</strong> Focusing on who appears as leaders, "influencers," "experts," and "icons," probing the sociotechnical biases.</li>
            </ul>
            <h3 id="section3-h3-2">Key Analysis Methods</h3>
            <ul id="section3-ul2">
                <li id="section3-ul2-li1"><strong>Automated Image Generation:</strong> Using "playwright" (Node.js library) to automate generation of 14 prompts, repeated 1008 times, for a large dataset.</li>
                <li id="section3-ul2-li2"><strong>Automated Bias Analysis:</strong> Using FairFace and/or DeepFace for gender/race/age analysis, calculating proportions, and visualizing trends (Python, Pandas, Seaborn).</li>
                <li id="section3-ul2-li3"><strong>Human Perception Analysis:</strong> Collecting diverse human judgments on perceived bias to quantify subjective experiences.</li>
                <li id="section3-ul2-li4"><strong>Direct Bias Evidence (Tier 1):</strong> Capturing visible prompt reconstructions from GPT/DALL-E, and using Stable Diffusion's "Interrogate CLIP" to compare input vs. internal interpretation.</li>
                <li id="section3-ul2-li5"><strong>Reverse-Engineering Analysis (Tier 2):</strong> Using standalone CLIP Interrogator tools for Midjourney, Gemini/Imagen, DeepAI, and cross-validating with alternative image-to-text models (BLIP-2, InstructBLIP).</li>
            </ul>
            <h3 id="section3-h3-3">Expected Impact</h3>
            <ul id="section3-ul3">
                <li id="section3-ul3-li1">Provides a crucial benchmark dataset and analysis framework for future fairness research in image/video generation.</li>
                <li id="section3-ul3-li2">Offers a clear, data-driven picture of how bias has evolved (or persisted) in popular generative models.</li>
                <li id="section3-ul3-li3">Provides actionable findings for AI developers, regulators, and users to guide the creation of truly safer, more inclusive tools.</li>
                <li id="section3-ul3-li4"><strong>Guides the development of fine-tuned models capable of generating images that reflect real-world demographic percentages (e.g., for gender, race) in various contexts.</strong></li>
            </ul>
        </section>

        <section>
            <h2>Highlighted Repositories</h2>
            <div class="projects">
                <a href="https://github.com/maxwell-khavari/ai-dataset-automation-script" target="_blank" rel="noopener noreferrer" class="github-link">Algorithmic Bias Progression Over Time (Main Project)</a>
                <a href="https://github.com/maxwell-khavari/classify" target="_blank" rel="noopener noreferrer" class="github-link">Race &amp; Gender Tagger</a>
                <a href="https://github.com/maxwell-khavari/cifar100_ai_image_models" target="_blank" rel="noopener noreferrer" class="github-link">CIFAR-100 Analysis with AI Models</a>
            </div>
        </section>
    </div>

    <footer>
        &copy; 2025 Maxwell Khavari â€¢ <a href="https://github.com/maxwell-khavari" target="_blank" rel="noopener noreferrer">GitHub Profile</a><br />
        <small>Summer Internship @ BMDS</small>
    </footer>

    <script>
        // Create animated background particles
        function createParticles() {
            const container = document.getElementById('particles');
            const particleCount = 70;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 10 + 's';
                particle.style.animationDuration = (Math.random() * 5 + 8) + 's';
                container.appendChild(particle);
            }
        }

        // --- JavaScript for Bouncing Words and Settling into Blur ---
        document.addEventListener('DOMContentLoaded', () => {
            createParticles(); // Initialize background particles

            const animatableTextSelectors = 'p, h1, h2, h3, ul li';
            const textElements = document.querySelectorAll(animatableTextSelectors);
            const wordDetails = [];
            
            const BOUNCE_DURATION = 3000; // milliseconds for the random bounce phase
            const SETTLE_DURATION = 1500; // milliseconds for words to settle into place
            const FINAL_BLUR_AMOUNT = 20; // Pixels of blur for illegible text
            const FINAL_OPACITY_AMOUNT = 0.5; // Final opacity (can be 1 for blurry but solid, or lower to fade)

            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            textElements.forEach(element => {
                const originalInnerHTML = element.innerHTML;
                let tempContent = originalInnerHTML;

                tempContent = tempContent.replace(/<strong>(.*?)<\/strong>/g, (match, p1) => `!!STRONG_START!!${p1}!!STRONG_END!!`);
                tempContent = tempContent.replace(/<span class="highlight">(.*?)<\/span>/g, (match, p1) => `!!HIGHLIGHT_START!!${p1}!!HIGHLIGHT_END!!`);
                tempContent = tempContent.replace(/<em>(.*?)<\/em>/g, (match, p1) => `!!EM_START!!${p1}!!EM_END!!`);

                const words = tempContent.split(/\s+/).filter(word => word.trim() !== '');

                const tempMeasurer = document.createElement('div');
                tempMeasurer.style.position = 'absolute';
                tempMeasurer.style.visibility = 'hidden';
                tempMeasurer.style.pointerEvents = 'none';
                tempMeasurer.style.width = getComputedStyle(element).width;
                tempMeasurer.style.fontFamily = getComputedStyle(element).fontFamily;
                tempMeasurer.style.fontSize = getComputedStyle(element).fontSize;
                tempMeasurer.style.fontWeight = getComputedStyle(element).fontWeight;
                tempMeasurer.style.lineHeight = getComputedStyle(element).lineHeight;
                tempMeasurer.style.letterSpacing = getComputedStyle(element).letterSpacing;
                tempMeasurer.style.wordSpacing = getComputedStyle(element).wordSpacing;
                tempMeasurer.style.padding = getComputedStyle(element).padding;
                tempMeasurer.style.margin = getComputedStyle(element).margin;
                tempMeasurer.style.border = getComputedStyle(element).border;
                tempMeasurer.style.boxSizing = getComputedStyle(element).boxSizing;

                if (getComputedStyle(element).display.includes('block')) {
                    tempMeasurer.style.display = 'block';
                } else {
                    tempMeasurer.style.display = 'inline-block';
                }

                document.body.appendChild(tempMeasurer);

                const wordContainer = document.createElement('div');
                wordContainer.className = 'word-container';
                const computedStyle = getComputedStyle(element);
                for (let i = 0; i < computedStyle.length; i++) {
                    const prop = computedStyle[i];
                    if (prop.startsWith('font') || prop.startsWith('text') || prop.startsWith('line') || prop.startsWith('padding') || prop.startsWith('margin') || prop.startsWith('border') || prop.startsWith('width') || prop.startsWith('height') || prop === 'display' || prop === 'box-sizing') {
                        wordContainer.style[prop] = computedStyle[prop];
                    }
                }
                wordContainer.style.position = 'relative';
                wordContainer.style.overflow = 'hidden';
                wordContainer.style.color = 'transparent';

                element.parentNode.replaceChild(wordContainer, element);
                element.style.visibility = 'hidden';

                words.forEach((word, index) => {
                    let processedWord = word;
                    let isStrong = false;
                    let isHighlight = false;
                    let isEm = false;

                    if (processedWord.includes('!!STRONG_START!!')) {
                        processedWord = processedWord.replace('!!STRONG_START!!', '').replace('!!STRONG_END!!', '');
                        isStrong = true;
                    }
                    if (processedWord.includes('!!HIGHLIGHT_START!!')) {
                        processedWord = processed.replace('!!HIGHLIGHT_START!!', '').replace('!!HIGHLIGHT_END!!', '');
                        isHighlight = true;
                    }
                     if (processedWord.includes('!!EM_START!!')) {
                        processedWord = processedWord.replace('!!EM_START!!', '').replace('!!EM_END!!', '');
                        isEm = true;
                    }

                    const tempWordSpan = document.createElement('span');
                    tempWordSpan.style.display = 'inline-block';
                    tempWordSpan.style.whiteSpace = 'nowrap';
                    tempWordSpan.textContent = processedWord + (index < words.length - 1 ? ' ' : '');

                    if (isStrong) tempWordSpan.style.fontWeight = 'bold';
                    if (isHighlight) tempWordSpan.className = 'highlight-word';
                    if (isEm) tempWordSpan.style.fontStyle = 'italic';

                    tempMeasurer.appendChild(tempWordSpan);

                    const rect = tempWordSpan.getBoundingClientRect();
                    const containerRect = wordContainer.getBoundingClientRect();

                    wordDetails.push({
                        originalElement: element,
                        wordContainer: wordContainer,
                        text: processedWord,
                        finalX: rect.left - containerRect.left,
                        finalY: rect.top - containerRect.top,
                        isStrong: isStrong,
                        isHighlight: isHighlight,
                        isEm: isEm,
                        wordSpan: null
                    });

                    if (index < words.length - 1) {
                         tempMeasurer.appendChild(document.createTextNode(' '));
                    }
                });
                 document.body.removeChild(tempMeasurer);
            });

            wordDetails.forEach(detail => {
                const span = document.createElement('span');
                span.className = 'word-particle';
                span.textContent = detail.text;

                if (detail.isStrong) span.style.fontWeight = 'bold';
                if (detail.isHighlight) span.classList.add('highlight-word');
                if (detail.isEm) span.style.fontStyle = 'italic';
                
                span.style.left = `${Math.random() * (viewportWidth * 1.5) - (viewportWidth * 0.25)}px`;
                span.style.top = `${Math.random() * (viewportHeight * 1.5) - (viewportHeight * 0.25)}px`;
                span.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg) scale(${Math.random() * 0.5 + 0.5})`;
                span.style.opacity = '0';
                span.style.filter = `blur(${Math.random() * 5 + 2}px)`;

                document.body.appendChild(span);
                detail.wordSpan = span;
            });

            setTimeout(() => {
                wordDetails.forEach(detail => {
                    const span = detail.wordSpan;
                    const randomDelay = Math.random() * (BOUNCE_DURATION * 0.8);
                    span.style.transition = `transform ${BOUNCE_DURATION / 1000}s ease-out ${randomDelay / 1000}s, opacity ${BOUNCE_DURATION / 1000}s ease-out ${randomDelay / 1000}s, filter ${BOUNCE_DURATION / 1000}s ease-out ${randomDelay / 1000}s`;
                    
                    span.style.left = `${Math.random() * (viewportWidth * 1.5) - (viewportWidth * 0.25)}px`;
                    span.style.top = `${Math.random() * (viewportHeight * 1.5) - (viewportHeight * 0.25)}px`;
                    span.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 720 - 360}deg) scale(${Math.random() * 0.5 + 0.8})`;
                    span.style.opacity = Math.random() * 0.8 + 0.2;
                    span.style.filter = `blur(${Math.random() * 3 + 1}px)`;
                });
            }, 100);

            // Settle words into a blurry, illegible state
            setTimeout(() => {
                wordDetails.forEach((detail, index) => {
                    const span = detail.wordSpan;
                    const wordContainer = detail.wordContainer;

                    // Append the word span to its target container
                    wordContainer.appendChild(span);

                    const settleDelay = (index * 20) + Math.random() * 200;
                    span.style.transition = `transform ${SETTLE_DURATION / 1000}s var(--transition-ease) ${settleDelay / 1000}s, opacity ${SETTLE_DURATION / 1000}s var(--transition-ease) ${settleDelay / 1000}s, filter ${SETTLE_DURATION / 1000}s var(--transition-ease) ${settleDelay / 1000}s`;
                    
                    // Animate to the final calculated position, but apply blur and chosen opacity
                    span.style.left = `${detail.finalX}px`;
                    span.style.top = `${detail.finalY}px`;
                    span.style.transform = `translate(0, 0) rotate(0deg) scale(1)`; 
                    span.style.opacity = `${FINAL_OPACITY_AMOUNT}`; // Final opacity
                    span.style.filter = `blur(${FINAL_BLUR_AMOUNT}px)`; // Final blur amount

                    // **Crucially, we are NOT removing 'position: absolute' or 'transform: none' here.**
                    // The words will remain absolutely positioned, blurry, and illegible.
                    // This means they won't be selectable as text in the normal way.
                    
                    // Restore original container overflow
                    setTimeout(() => {
                        wordContainer.style.overflow = 'visible';
                    }, SETTLE_DURATION + 500); // A bit after last word has settled
                });

            }, BOUNCE_DURATION + 500);

            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });
        });
    </script>
</body>
</html>
